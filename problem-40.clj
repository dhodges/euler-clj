#^:shebang '[
             exec clj clojure.lang.Script "$0" -- "$@"
             ]

(ns user)

;; http://projecteuler.net/index.php?section=problems&id=40
;;
;; Problem 40
;; 28 March 2003
;;
;; An irrational decimal fraction is created by concatenating the
;; positive integers:
;;
;; 0.123456789101112131415161718192021...
;;              ^
;;
;; It can be seen that the 12th digit of the fractional part is 1.
;;
;; If d(n) represents the nth digit of the fractional part,
;; find the value of the following expression.
;;
;; d(1) × d(10) × d(100) × d(1000) × d(10000) × d(100000) × d(1000000)

; Notes

;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354
;; 5556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021
;; 0310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513
;; 6137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169
;; 1701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022
;; 0320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523
;; 6237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269
;; 2702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023
;; 0330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533
;; 6337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369
;; 3703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024
;; 0340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543
;; 6437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469
;; 4704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025
;; 0350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553
;; 6537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569
;; 5705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026
;; 0360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563
;; 6637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669
;; 6706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027
;; 0370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573  <---
;; 6737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769
;; 7707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028
;; 0380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583
;; 6837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869
;; 8708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029
;; 0390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593
;; 6937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969
;; 9709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110
;; 0210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610
;; 2710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110
;; 5210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610
;; 7710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100



(defn num-sequence
  []
  (let [nums (fn nums [n] (lazy-cons n (nums (inc n))))]
    (nums 1)))


(defn nth-digit-of
  "return nth digit of num: (0 .. n-1)"
  [num n]
  (- (int (nth (str num) n)) 48))
  

(defn index
  [n]
  (cond (< n 10) n
        (< n 190) (+ 10 (quot (- n 10) 2))
        (< n 2890) (+ 100 (quot (- n 190) 3))
        (< n 29890) (+ 1000 (quot (- n 2890) 4))
        (< n 299890) (+ 10000 (quot (- n 29890) 5))
        (< n 2999890) (+ 100000 (quot (- n 299890) 6))
        ))

(defn test-index
  []
  (assert (= (index 20) 15))
  (assert (= (index 21) 15))
  (assert (= (index 22) 16))
  (assert (= (index 23) 16))
  (assert (= (index 24) 17))
  (assert (= (index 100) 55))
  (assert (= (index 150) 80))
  (assert (= (index 2100) 736)))


(defn qr
  "returns the quotient and remainder"
  [n d]
  [(quot n d) (rem n d)])


(defn d
  [n]
  (cond (< n 10) n
        (< n 190) (let [[q r] (qr (- n 10) 2)]
                    (nth-digit-of (+ 10 q) r))
        
        (< n 2890) (let [[q r] (qr (- n 190) 3)]
                     (nth-digit-of (+ 100 q) r)) 

        (< n 29890) (let [[q r] (qr (- n 2890) 4)]
                      (nth-digit-of (+ 1000 q) r))
        
        (< n 299890) (let [[q r] (qr (- n 29890) 5)]
                       (nth-digit-of (+ 10000 q) r))

        (< n 2999890) (let [[q r] (qr (- n 299890) 6)]
                        (nth-digit-of (+ 100000 q) r))
        ))


(defn solution
  []
  (time
   (* (d 1) (d 10) (d 100) (d 1000) (d 10000) (d 100000) (d 1000000))))


(defn- member?
  [item coll]
  (cond (empty? coll)
        false
        (= item (first coll))
        true
        :else
        (recur item (rest coll))))

(defn test-solution
  []
  (let [s (solution)]
    (not (member? s [84 420]))))

